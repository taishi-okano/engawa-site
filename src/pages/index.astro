---
// engawa - Bishamonkikkou Sphere Edition
---

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>engawa — Taishi Okano</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,500;0,600;1,400&family=DM+Sans:wght@300;400;500;600&display=swap" rel="stylesheet">

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Person",
    "name": "Taishi Okano",
    "url": "https://taishiokano.com",
    "nationality": { "@type": "Country", "name": "Japan" },
    "jobTitle": "Product Strategy",
    "knowsAbout": ["AI", "UX", "Technology", "Traditional Japanese Crafts", "Mingei", "Design Philosophy"],
    "description": "Exploring the intersection of AI, UX, and the timeless wisdom of Japanese crafts."
  }
  </script>

  <style>
    :root {
      --bg: #F5F0E8;
      --sumi: #1C1917;
      --text: #3D3935;
      --kakishibu: #D4976C;
      --line: rgba(28, 25, 23, 0.08);
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    html { font-size: 16px; scroll-behavior: smooth; }
    ::selection { background: var(--sumi); color: var(--bg); }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'DM Sans', sans-serif;
      -webkit-font-smoothing: antialiased;
      overflow-x: hidden;
      min-height: 200vh;
    }

    .hero {
      height: 100vh;
      display: flex;
      flex-direction: column;
      position: sticky;
      top: 0;
      overflow: hidden;
      z-index: 10;
    }

    .nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 2rem 3rem;
      z-index: 100;
      position: relative;
    }

    .logo { font-family: 'Lora', serif; font-size: 1.1rem; font-weight: 600; text-decoration: none; color: var(--sumi); letter-spacing: 0.08em; }
    .nav-links { display: flex; gap: 2.5rem; }
    .nav-links a { font-size: 0.85rem; opacity: 0.6; text-decoration: none; transition: 0.3s; color: var(--sumi); }
    .nav-links a:hover { opacity: 1; }

    .hero-content { flex: 1; display: flex; align-items: center; justify-content: center; position: relative; }
    .hero-title { font-family: 'Lora', serif; font-size: clamp(4rem, 10vw, 9rem); font-weight: 600; color: var(--sumi); position: absolute; top: 20%; left: 3rem; z-index: 50; pointer-events: none; }
    .hero-caption { font-size: 0.7rem; letter-spacing: 0.12em; text-transform: uppercase; opacity: 0.5; position: absolute; top: 15%; left: 3rem; z-index: 50; }
    .hero-tagline { font-family: 'Lora', serif; font-size: 1.15rem; font-style: italic; max-width: 26ch; opacity: 0.6; position: absolute; bottom: 15%; right: 3rem; text-align: right; z-index: 50; }

    .sphere-container { position: absolute; width: 600px; height: 600px; z-index: 20; pointer-events: none; }
    #sphereCanvas { width: 100%; height: 100%; border-radius: 50%; }

    .scroll-spacer { height: 105vh; pointer-events: none; }

    .posts-section {
      min-height: 100vh;
      padding: 8rem 3rem;
      background: var(--bg);
      z-index: 100;
      position: relative;
    }

    .posts-container { max-width: 1400px; margin: 0 auto; }
    .section-label { font-size: 0.75rem; letter-spacing: 0.18em; text-transform: uppercase; opacity: 0.4; margin-bottom: 3rem; padding-bottom: 1rem; border-bottom: 1px solid var(--line); }

    .post-item {
      padding: 2.5rem 2rem;
      margin: 0 -2rem;
      border-bottom: 1px solid var(--line);
      cursor: pointer;
      transition: background 0.4s ease, padding-left 0.4s ease;
      border-radius: 4px;
      text-decoration: none;
      display: block;
    }

    .post-item:hover {
      background: var(--sumi);
      padding-left: 3rem;
    }

    .post-date { font-size: 0.8rem; opacity: 0.5; margin-bottom: 0.4rem; color: var(--text); transition: 0.4s; }
    .post-content h3 { font-family: 'Lora', serif; font-size: 2rem; font-weight: 500; line-height: 1.3; color: var(--sumi); transition: 0.4s; }

    .post-item:hover .post-date { color: var(--bg); opacity: 0.6; }
    .post-item:hover h3 { color: var(--bg); }

    .post-item.touch-active {
      background: var(--sumi);
      padding-left: 3rem;
    }
    .post-item.touch-active .post-date { color: var(--bg); opacity: 0.6; }
    .post-item.touch-active h3 { color: var(--bg); }

    footer { padding: 4rem 3rem; border-top: 1px solid var(--line); opacity: 0.4; font-size: 0.7rem; display: flex; justify-content: space-between; }

    @media (max-width: 768px) {
      .nav { padding: 1.5rem 1.5rem; }
      .hero-title { left: 1.5rem; }
      .hero-caption { left: 1.5rem; }
      .hero-tagline { right: 1.5rem; font-size: 1rem; }
      .sphere-container { width: 324px; height: 324px; }
      .posts-section { padding: 5rem 1.5rem; }
      .post-content h3 { font-size: 1.4rem; }
      .post-item { padding: 2rem 1.5rem; margin: 0 -1.5rem; }
      .post-item:hover, .post-item.touch-active { padding-left: 2rem; }
      footer { padding: 3rem 1.5rem; flex-direction: column; gap: 0.5rem; }
    }
  </style>
</head>
<body>

  <section class="hero">
    <nav class="nav">
      <a href="/" class="logo">engawa</a>
      <div class="nav-links">
        <a href="#writing">Writing</a>
        <a href="/about">About</a>
      </div>
    </nav>
    <div class="hero-content">
      <p class="hero-caption" id="caption">In praise of friction</p>
      <h1 class="hero-title" id="title">engawa</h1>
      <div class="sphere-container" id="sphereContainer">
        <canvas id="sphereCanvas"></canvas>
      </div>
      <p class="hero-tagline" id="tagline">Where technology meets the grain of human things.</p>
    </div>
  </section>

  <div class="scroll-spacer"></div>

  <section class="posts-section" id="writing">
    <div class="posts-container">
      <div class="section-label">Writing</div>
      <a href="#" class="post-item">
        <div class="post-content">
          <p class="post-date">Feb 2026</p>
          <h3>Why the Future of AI and UX Depends on Interfaces Beyond Screens</h3>
        </div>
      </a>
    </div>
  </section>

  <footer>
    <div>engawa · Taishi Okano</div>
    <div>© 2026 · New York / Tokyo</div>
  </footer>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script is:inline>
    function startSphere() {
      const canvas = document.getElementById('sphereCanvas');
      if (!canvas || typeof THREE === 'undefined') return;

      const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(600, 600);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(38, 1, 0.1, 100);
      camera.position.z = 4.2;

      const group = new THREE.Group();
      scene.add(group);

      const R = 1.45;
      const kakishibu = new THREE.Color('#D4976C');
      const kakishibuLight = new THREE.Color('#E0B090');

      // ======================================================
      // BISHAMONKIKKOU (毘沙門亀甲) SPHERE
      //
      // The pattern is built on a dual of the geodesic sphere:
      // 1. Subdivide icosahedron → triangular mesh
      // 2. Build dual mesh → hex/pent cells (Goldberg polyhedron)
      // 3. For each hex cell, draw the bishamonkikkou motif:
      //    - Outer hexagon ring (with angular indentations)
      //    - Inner Y-triskelion from center to alternating edges
      //    - Double-line effect for authentic look
      // ======================================================

      // --- Icosahedron ---
      const phi = (1 + Math.sqrt(5)) / 2;
      const icoV = [
        [-1, phi, 0],[1, phi, 0],[-1,-phi, 0],[1,-phi, 0],
        [0,-1, phi],[0, 1, phi],[0,-1,-phi],[0, 1,-phi],
        [phi, 0,-1],[phi, 0, 1],[-phi, 0,-1],[-phi, 0, 1]
      ].map(v => new THREE.Vector3(...v).normalize());

      const icoF = [
        [0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],
        [1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],
        [3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],
        [4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1]
      ];

      // --- Subdivide ---
      function subdivide(verts, faces, n) {
        let v = verts.map(p => p.clone());
        let f = faces;
        for (let d = 0; d < n; d++) {
          const cache = {};
          const nf = [];
          function mid(a, b) {
            const k = Math.min(a,b) + ':' + Math.max(a,b);
            if (cache[k] !== undefined) return cache[k];
            v.push(new THREE.Vector3().addVectors(v[a], v[b]).normalize());
            cache[k] = v.length - 1;
            return cache[k];
          }
          for (const [a,b,c] of f) {
            const ab = mid(a,b), bc = mid(b,c), ca = mid(c,a);
            nf.push([a,ab,ca],[b,bc,ab],[c,ca,bc],[ab,bc,ca]);
          }
          f = nf;
        }
        return { v, f };
      }

      const mesh = subdivide(icoV, icoF, 3);

      // --- Build dual: for each original vertex, collect surrounding face centers ---
      // This gives us hexagonal (and pentagonal at 12 ico vertices) cells

      // Face centers
      const fCenters = mesh.f.map(([a,b,c]) =>
        new THREE.Vector3().addVectors(mesh.v[a], mesh.v[b]).add(mesh.v[c]).multiplyScalar(1/3).normalize()
      );

      // Vertex → face adjacency
      const vertToFaces = {};
      mesh.f.forEach((face, fi) => {
        face.forEach(vi => {
          if (!vertToFaces[vi]) vertToFaces[vi] = [];
          vertToFaces[vi].push(fi);
        });
      });

      // For each vertex, sort its surrounding faces in angular order
      function sortFacesAroundVertex(vi, faceIndices) {
        const vn = mesh.v[vi];
        // Build local coordinate frame
        let up = new THREE.Vector3(0, 1, 0);
        if (Math.abs(vn.dot(up)) > 0.99) up = new THREE.Vector3(1, 0, 0);
        const tx = new THREE.Vector3().crossVectors(vn, up).normalize();
        const ty = new THREE.Vector3().crossVectors(vn, tx).normalize();

        return faceIndices.sort((a, b) => {
          const ca = fCenters[a];
          const cb = fCenters[b];
          const angA = Math.atan2(ca.dot(ty), ca.dot(tx));
          const angB = Math.atan2(cb.dot(ty), cb.dot(tx));
          return angA - angB;
        });
      }

      // Slerp helper
      function slerp(a, b, t) {
        const dot = Math.max(-1, Math.min(1, a.dot(b)));
        const omega = Math.acos(dot);
        if (omega < 1e-5) return a.clone().lerp(b, t).normalize();
        const so = Math.sin(omega);
        return a.clone().multiplyScalar(Math.sin((1-t)*omega)/so)
          .add(b.clone().multiplyScalar(Math.sin(t*omega)/so)).normalize();
      }

      // Arc on sphere
      function arc(p1, p2, segs) {
        const pts = [];
        for (let i = 0; i <= segs; i++) pts.push(slerp(p1, p2, i/segs));
        return pts;
      }

      // Create THREE.Line on sphere surface
      function makeLine(points, color, opacity) {
        const geom = new THREE.BufferGeometry().setFromPoints(
          points.map(p => p.clone().normalize().multiplyScalar(R))
        );
        return new THREE.Line(geom, new THREE.LineBasicMaterial({
          color, transparent: true, opacity
        }));
      }

      // ======================================================
      // DRAW BISHAMONKIKKOU CELLS
      //
      // For each vertex (= dual cell center):
      //   - The sorted face centers around it form the hex/pent ring
      //   - Draw the outer ring with inward notches (the "kikkō" shape)
      //   - Draw Y-arms from cell center toward alternating edges
      //   - Add parallel inner lines for the double-stroke effect
      // ======================================================

      const cellsDrawn = new Set();

      Object.keys(vertToFaces).forEach(viStr => {
        const vi = parseInt(viStr);
        const fIndices = vertToFaces[vi];
        if (!fIndices || fIndices.length < 5) return;

        const sorted = sortFacesAroundVertex(vi, [...fIndices]);
        const n = sorted.length; // 5 or 6
        const cellCenter = mesh.v[vi].clone().normalize();
        const ring = sorted.map(fi => fCenters[fi].clone());

        // --- Outer hexagonal ring ---
        // Bishamonkikkou: the hex outline has angular indentations
        // at alternating edges, creating the interlocking Y pattern.
        // We draw: for each pair of adjacent ring points, add a
        // slight inward bend at the midpoint of alternating edges.

        for (let i = 0; i < n; i++) {
          const curr = ring[i];
          const next = ring[(i + 1) % n];
          const edgeMid = slerp(curr, next, 0.5);

          if (i % 2 === 0) {
            // Indented edge: pull midpoint inward toward cell center
            const indented = slerp(edgeMid, cellCenter, 0.28).normalize();
            const pts = [
              ...arc(curr, indented, 4),
              ...arc(indented, next, 4).slice(1)
            ];
            group.add(makeLine(pts, kakishibu, 0.5));

            // Inner parallel line
            const innerCurr = slerp(curr, cellCenter, 0.1).normalize();
            const innerNext = slerp(next, cellCenter, 0.1).normalize();
            const innerIndented = slerp(indented, cellCenter, 0.08).normalize();
            const innerPts = [
              ...arc(innerCurr, innerIndented, 3),
              ...arc(innerIndented, innerNext, 3).slice(1)
            ];
            group.add(makeLine(innerPts, kakishibuLight, 0.2));
          } else {
            // Straight edge (slightly outward for the kikkō bulge)
            const bulged = slerp(edgeMid, cellCenter, -0.08).normalize();
            const pts = [
              ...arc(curr, bulged, 4),
              ...arc(bulged, next, 4).slice(1)
            ];
            group.add(makeLine(pts, kakishibu, 0.5));

            // Inner parallel
            const innerCurr = slerp(curr, cellCenter, 0.1).normalize();
            const innerNext = slerp(next, cellCenter, 0.1).normalize();
            const innerBulged = slerp(bulged, cellCenter, 0.06).normalize();
            const innerPts = [
              ...arc(innerCurr, innerBulged, 3),
              ...arc(innerBulged, innerNext, 3).slice(1)
            ];
            group.add(makeLine(innerPts, kakishibuLight, 0.2));
          }
        }

        // --- Y-triskelion arms from center ---
        // Arms extend from center toward the indented edges (even-indexed)
        for (let i = 0; i < n; i += 2) {
          const target = ring[i];
          const next = ring[(i + 1) % n];
          const edgeMid = slerp(target, next, 0.5);
          const indented = slerp(edgeMid, cellCenter, 0.28).normalize();

          // Main arm: center → indented point
          const armPts = arc(cellCenter, indented, 6);
          group.add(makeLine(armPts, kakishibu, 0.45));

          // Inner parallel arm (offset slightly)
          const prev = ring[(i + n - 1) % n];
          const offsetDir = slerp(cellCenter, prev, 0.08).normalize();
          const innerStart = slerp(cellCenter, offsetDir, 0.12).normalize();
          const innerEnd = slerp(indented, offsetDir, 0.06).normalize();
          const innerArm = arc(innerStart, innerEnd, 4);
          group.add(makeLine(innerArm, kakishibuLight, 0.18));
        }
      });

      // --- Scroll & Friction Logic ---
      let currentScrollP = 0; // 現在の描画上の位置
      let targetScrollP = 0;  // 実際のスクロール位置
      const friction = 0.06;  // 摩擦係数（小さいほどゆっくり、重厚になります）

      let floatX = 0, floatY = 0;
      const sc = document.getElementById('sphereContainer');
      const title = document.getElementById('title');
      const caption = document.getElementById('caption');
      const tagline = document.getElementById('tagline');

      // --- Animate ---
      function animate(time) {
        requestAnimationFrame(animate);

        // Lerp: 現在値を目標値に少しずつ近づける
        currentScrollP += (targetScrollP - currentScrollP) * friction;

        group.rotation.y += 0.002;
        group.rotation.x += 0.0007;

        // Microgravity float
        const t = time * 0.001;
        floatX = Math.sin(t * 0.23) * 24 + Math.sin(t * 0.37 + 1.2) * 16 + Math.sin(t * 0.71 + 3.7) * 8;
        floatY = Math.sin(t * 0.19 + 0.8) * 20 + Math.sin(t * 0.41 + 2.5) * 14 + Math.sin(t * 0.67 + 5.1) * 6;

        // Apply combined transform: float + scroll scale (using currentScrollP)
        if (sc) {
          const scale = 1 + currentScrollP * 5;
          sc.style.transform = `translate(${floatX}px, ${floatY}px) scale(${scale})`;
          // 透明度の同期も Lerp させることで滑らかに
          sc.style.opacity = Math.max(0, 1 - (currentScrollP * 1.5)).toString();
        }

        // テキストの不透明度も Lerp に同期
        if (title) title.style.opacity = Math.max(0, 1 - currentScrollP * 2.5).toString();
        if (caption) caption.style.opacity = Math.max(0, 0.5 - currentScrollP * 2.5).toString();
        if (tagline) tagline.style.opacity = Math.max(0, 0.6 - currentScrollP * 2.5).toString();

        renderer.render(scene, camera);
      }
      animate(0);

      // --- Scroll Event (Update Target Only) ---
      window.addEventListener('scroll', () => {
        // スクロール時は目標値（target）を更新するだけにする
        targetScrollP = Math.min(window.scrollY / window.innerHeight, 1.2);
      });

    if (document.readyState === 'complete') {
      startSphere();
    } else {
      window.addEventListener('load', startSphere);
    }

    // Mobile touch inversion
    document.addEventListener('DOMContentLoaded', () => {
      const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      if (!isTouchDevice) return;
      document.querySelectorAll('.post-item').forEach(item => {
        item.addEventListener('touchstart', () => item.classList.add('touch-active'), { passive: true });
        item.addEventListener('touchend', () => setTimeout(() => item.classList.remove('touch-active'), 300), { passive: true });
        item.addEventListener('touchcancel', () => item.classList.remove('touch-active'), { passive: true });
      });
    });
  </script>
</body>
</html>